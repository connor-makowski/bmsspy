\begin{algorithm}[!htbp]
\caption{Initialize BmsspDataStructure (\texttt{BmsspDataStructure.\_\_init\_\_})}
\label{alg:bmssp_init}
\SetAlgoLined
\KwIn{subset size $M$, upper bound $B$}
\KwOut{empty structure with parameters $(M,B)$}

$\textit{subset\_size} \leftarrow \max(1,M)$\;
$\textit{upper\_bound} \leftarrow B$\;
$\textit{best} \leftarrow \{\}$ \tcp{map: key $\to$ best value}
$\textit{heap} \leftarrow [\,]$\;
\end{algorithm}


\begin{algorithm}[!htbp]
\caption{Insert or Refresh (\texttt{BmsspDataStructure.insert\_key\_value})}
\label{alg:bmssp_insert}
\SetAlgoLined
\KwIn{key $k$, value $v$}
\If{$v < \textit{best}.get(k, \infty)$}{
  $\textit{best}[k] \leftarrow v$\;
  \textsc{Push}($\textit{heap}, (v,k)$)\;
}
\end{algorithm}


\begin{algorithm}[!htbp]
\caption{Pop Current Minimum (\texttt{BmsspDataStructure.pop\_current})}
\label{alg:bmssp_pop}
\SetAlgoLined
\KwOut{next key with valid minimum value or None}

\While{$\textit{heap}$ not empty}{
  $(v,k)\leftarrow$\textsc{Pop}($\textit{heap}$)\;
  \If{$\textit{best}.get(k,\infty)=v$}{
    remove $k$ from \textit{best}\;
    \Return{$k$}\;
  }
}
\Return{None}\;
\end{algorithm}


\begin{algorithm}[!htbp]
\caption{Check Empty (\texttt{BmsspDataStructure.is\_empty})}
\label{alg:bmssp_empty}
\SetAlgoLined
\KwOut{true if structure is empty}

\Return{$|\textit{best}|=0$}\;
\end{algorithm}


\begin{algorithm}[!htbp]
\caption{Pull Subset (\texttt{BmsspDataStructure.pull})}
\label{alg:bmssp_pull}
\SetAlgoLined
\KwOut{pair $(r, U)$ where $U$ = up to $M$ smallest keys, $r$ = remaining best value or $B$ if empty}

$U \leftarrow \emptyset$; $count \leftarrow 0$\;
\While{$count < M$}{
  $k \leftarrow$\textsc{PopCurrent}()\;
  \If{$k=$ None}{\textbf{break}}
  $U \leftarrow U \cup \{k\}$; $count \leftarrow count+1$\;
}
\If{\textit{best} not empty}{$r \leftarrow \min(\textit{best.values})$}
\Else{$r \leftarrow B$}
\Return{$(r,U)$}\;
\end{algorithm}


\begin{algorithm}[!htbp]
\caption{Batch Insert (\texttt{BmsspDataStructure.batch\_insert})}
\label{alg:bmssp_batch_insert}
\SetAlgoLined
\KwIn{set of pairs $\{(k,v)\}$}
\ForEach{$(k,v)$ in pairs}{
  \If{$v < \textit{best}.get(k,\infty)$}{
    $\textit{best}[k] \leftarrow v$\;
    \textsc{Push}($\textit{heap}, (v,k)$)\;
  }
}
\end{algorithm}

Note: The BmsspDataStructure.batch_insert_alt is not used since it is slower in practice even though it only requires calculating the heap invariant once. 
See: the applied tests in benchmarking.outputs.data_struct_time_tests.csv
Note: Do we actually want to talk about this?

\begin{algorithm}[!htbp]
\caption{Batch Insert (Alternate) (\texttt{BmsspDataStructure.batch\_insert\_alt})}
\label{alg:bmssp_batch_insert_alt}
\SetAlgoLined
\KwIn{set of pairs $\{(k,v)\}$}
\ForEach{$(k,v)$ in pairs}{
  \If{$v < \textit{best}.get(k,\infty)$}{
    $\textit{best}[k] \leftarrow v$\;
    append $(v,k)$ to \textit{heap}\;
  }
}
\textsc{Heapify}(\textit{heap})\;
\end{algorithm}