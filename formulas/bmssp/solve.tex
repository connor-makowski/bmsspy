\begin{algorithm}[!htbp]
\SingleSpacedXI
\caption{{\color{Red}BMSSP Solve (E2E) (\texttt{BmsspCore.\_\_init\_\_} \& \texttt{Bmssp.solve})}}
\label{alg:bmssp_solve}
\SetAlgoLined
\KwIn{origin set $O$, destination id $dest$ (optional)}
\KwOut{dictionary with path, length, distance matrix, and predecessor}

$\textit{dist}[0..|G|-1] \leftarrow \infty$\;
{\color{Sepia}$\textit{cdist}[0..|G|-1] \leftarrow \infty$ \tcp*{RUA: Create counter distance matrix}\label{alg:bmssp_solve_cdist}}
{\color{ForestGreen}$\textit{pred}[0..|G|-1] \leftarrow -1$ \tcp*{PT: Create predecessors track for path reconstruction}\label{alg:bmssp_solve_pred}}

\ForEach{$o \in O$}{
  $\textit{dist}[o] \leftarrow 0$\;
  {\color{Sepia}$\textit{cdist}[o] \leftarrow 0$\;}
}

\BlankLine
{\color{blue}$k \leftarrow \lfloor \log_2(|G|)^{1/3} \rfloor$ \tcp*{FIN: Use $log_2$}\label{alg:bmssp_solve_k}}

{\color{blue}$t \leftarrow \lfloor \log_2(|G|)^{2/3} \rfloor$ \tcp*{FIN: Use $log_2$}\label{alg:bmssp_solve_t}}
{\color{blue}$l \leftarrow \left\lceil \dfrac{\log_2(|G|)}{t} \right\rceil$\  \tcp*{FIN: Use $log_2$}\label{alg:bmssp_solve_l}}

\BlankLine
$(B, U) \leftarrow$ \textsc{RecursiveBMSSP}($l, \infty, O$) \tcp*{Algorithm \ref{alg:bmssp_recursive_bmssp}}

\BlankLine
{\color{Brown}
  \ForEach{$i \in \textit{dist}$}{
    \If{$\textit{dist}[i] \neq \infty$}{
      $\textit{dist}[i] \leftarrow \text{round}(\textit{dist}[i], p)$\tcp*{RUA: Convert back to original precision}\label{alg:bmssp_solve_precision_adjustment}
    }
  }
}

\BlankLine
{\color{Red}
  \eIf{$dest \neq \text{None}$}{
    {\color{ForestGreen}$\textit{path} \leftarrow \textsc{ReconstructPath}(dest, \textit{pred})$\tcp*{PT: Algorithm \ref{alg:utils_reconstruct_path}}}
    $\textit{length} \leftarrow \textit{dist}[dest]$\;
  }{
    {\color{ForestGreen}$\textit{path} \leftarrow \text{None}$\;}
    $\textit{length} \leftarrow \text{None}$\;
  }
}

\BlankLine
\Return dictionary with keys: $O$, $dest$, $\textit{pred}$, $\textit{dist}$, $\textit{path}$, $\textit{length}$\;

\end{algorithm}