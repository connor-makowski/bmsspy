window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "bmsspy", "modulename": "bmsspy", "kind": "module", "doc": "<h1 id=\"bmsspy\">BMSSPy</h1>\n\n<p><a href=\"https://badge.fury.io/py/bmsspy\"><img src=\"https://badge.fury.io/py/bmsspy.svg\" alt=\"PyPI version\" /></a>\n<a href=\"https://opensource.org/licenses/MIT\"><img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"License: MIT\" /></a>\n<!-- <a href=\"https://pypi.org/project/bmsspy/\"><img src=\"https://img.shields.io/pypi/dm/bmsspy.svg?label=PyPI%20downloads\" alt=\"PyPI Downloads\" /></a> --></p>\n\n<p>A pure python bmssp implementation.</p>\n\n<h1 id=\"setup\">Setup</h1>\n\n<p>Make sure you have Python 3.11.x (or higher) installed on your system. You can download it <a href=\"https://www.python.org/downloads/\">here</a>.</p>\n\n<h3 id=\"installation\">Installation</h3>\n\n<pre><code>pip install bmsspy\n</code></pre>\n\n<h3 id=\"documentation\">Documentation</h3>\n\n<ul>\n<li>Github: <a href=\"https://github.com/connor-makowski/bmsspy\">https://github.com/connor-makowski/bmsspy</a></li>\n<li>Docs: <a href=\"https://connor-makowski.github.io/bmsspy/bmsspy.html\">https://connor-makowski.github.io/bmsspy/bmsspy.html</a></li>\n<li>Paper: <a href=\"https://ssrn.com/abstract=5777186\">https://ssrn.com/abstract=5777186</a></li>\n</ul>\n\n<h3 id=\"how-to-cite-bmsspy-in-your-research\">How to Cite BMSSPy in your Research</h3>\n\n<p>If you use BMSSPy for your research, please consider citing the following paper:</p>\n\n<blockquote>\n  <p>Makowski, Connor and Guter, Willem and Russell, Tim and Saragih, Austin, BMSSPy: A Python Package and Empirical Comparison of Bounded Multi-Source Shortest Path Algorithm (November 19, 2025). MIT Center for Transportation &amp; Logistics Research Paper No. 2025/034, Available at SSRN: <a href=\"https://ssrn.com/abstract=5777186\">https://ssrn.com/abstract=5777186</a></p>\n</blockquote>\n\n<p>Or by using the BibTeX entry:</p>\n\n<pre><code>@article{makowski2025bmsspy,\n  title={BMSSPy: A Python Package and Empirical Comparison of Bounded Multi-Source Shortest Path Algorithm},\n  author={Makowski, Connor and Guter, Willem and Russell, Tim and Saragih, Austin},\n  journal={MIT Center for Transportation &amp; Logistics Research Paper Series},\n  number={2025-034},\n  year={2025},\n  url={https://ssrn.com/abstract=5777186}\n}\n</code></pre>\n\n<h3 id=\"use\">Use</h3>\n\n<p>The example use cases in this section are based on the following graph:</p>\n\n<p><img src=\"https://raw.githubusercontent.com/connor-makowski/bmsspy/main/static/readme_graph.png\" alt=\"readme_graph\" /></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">bmsspy</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">Bmssp</span>\n\n<span class=\"c1\"># Graph with 5 nodes: 0..4</span>\n<span class=\"c1\"># Adjacency-list representation with nonnegative weights</span>\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">},</span>   <span class=\"c1\"># 0 -&gt; 1 (1), 0 -&gt; 2 (1)</span>\n    <span class=\"p\">{</span><span class=\"mi\">2</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">},</span>   <span class=\"c1\"># 1 -&gt; 2 (1), 1 -&gt; 3 (3)</span>\n    <span class=\"p\">{</span><span class=\"mi\">3</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">},</span>   <span class=\"c1\"># 2 -&gt; 3 (1), 2 -&gt; 4 (2)</span>\n    <span class=\"p\">{</span><span class=\"mi\">4</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">},</span>         <span class=\"c1\"># 3 -&gt; 4 (2)</span>\n    <span class=\"p\">{}</span>              <span class=\"c1\"># 4 has no outgoing edges</span>\n<span class=\"p\">]</span>\n\n<span class=\"n\">bmssp_graph</span> <span class=\"o\">=</span> <span class=\"n\">Bmssp</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"p\">)</span> <span class=\"c1\"># Initialize the graph as a Bmssp graph</span>\n\n<span class=\"c1\"># Distances and predecessors from origin 0</span>\n<span class=\"n\">res_0</span> <span class=\"o\">=</span> <span class=\"n\">bmssp_graph</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">origin_id</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">res_0</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt;</span>\n<span class=\"c1\"># {</span>\n<span class=\"c1\">#     &#39;origin_id&#39;: 0,</span>\n<span class=\"c1\">#     &#39;destination_id&#39;: None,</span>\n<span class=\"c1\">#     &#39;predecessor&#39;: [-1, 0, 0, 2, 2],</span>\n<span class=\"c1\">#     &#39;distance_matrix&#39;: [0.0, 1.0, 1.0, 2.0, 3.0],</span>\n<span class=\"c1\">#     &#39;path&#39;: None,</span>\n<span class=\"c1\">#     &#39;length&#39;: None</span>\n<span class=\"c1\"># }</span>\n\n<span class=\"c1\"># Shortest path from 0 to 4</span>\n<span class=\"n\">res_0_4</span> <span class=\"o\">=</span> <span class=\"n\">bmssp_graph</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">origin_id</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">destination_id</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">res_0_4</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt;</span>\n<span class=\"c1\"># {</span>\n<span class=\"c1\">#     &#39;origin_id&#39;: 0,</span>\n<span class=\"c1\">#     &#39;destination_id&#39;: 4,</span>\n<span class=\"c1\">#     &#39;predecessor&#39;: [-1, 0, 0, 2, 2],</span>\n<span class=\"c1\">#     &#39;distance_matrix&#39;: [0.0, 1.0, 1.0, 2.0, 3.0],</span>\n<span class=\"c1\">#     &#39;path&#39;: [0, 2, 4],</span>\n<span class=\"c1\">#     &#39;length&#39;: 3</span>\n<span class=\"c1\"># }</span>\n</code></pre>\n</div>\n\n<p>In the example above, we only use a single orign, however multiple origins are supported if passed as a set:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># Pass orgin_id as a set of ids</span>\n<span class=\"n\">res_02</span> <span class=\"o\">=</span> <span class=\"n\">bmssp_graph</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">origin_id</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">})</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">res_02</span><span class=\"p\">)</span> <span class=\"c1\">#=&gt;</span>\n<span class=\"c1\"># {</span>\n<span class=\"c1\">#     &#39;origin_id&#39;: [0, 2],</span>\n<span class=\"c1\">#     &#39;destination_id&#39;: None,</span>\n<span class=\"c1\">#     &#39;predecessor&#39;: [-1, 0, -1, 2, 2],</span>\n<span class=\"c1\">#     &#39;distance_matrix&#39;: [0.0, 1.0, 0.0, 1.0, 2.0],</span>\n<span class=\"c1\">#     &#39;path&#39;: None,</span>\n<span class=\"c1\">#     &#39;length&#39;: None</span>\n<span class=\"c1\"># }</span>\n</code></pre>\n</div>\n\n<p>By default graphs that are given are converted to constant degree such that worst case asymtotic run times are based on the constant degree converted graphs. Before returning a result, the constant degree conversion is undone such that the results are in the original passed graph format.</p>\n\n<p>Most real world graphs are not constant degree. Converting to constant degree graphs can add substantial operational overhead during pre and post processing as well as during the actual algorithmic runtime.</p>\n\n<p>To skip the constant degree conversion:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># Set use_constant_degree_graph=False</span>\n<span class=\"n\">bmssp_graph</span> <span class=\"o\">=</span> <span class=\"n\">Bmssp</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"o\">=</span><span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">use_constant_degree_graph</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h2 id=\"development\">Development</h2>\n\n<p>To avoid extra development overhead, we expect all developers to use a unix based environment (Linux or Mac). If you use Windows, please use WSL2.</p>\n\n<p>For development, we test using Docker so we can lock system deps and swap out python versions easily. However, you can also use a virtual environment if you prefer. We provide a test script and a prettify script to help with development.</p>\n\n<h3 id=\"making-changes\">Making Changes</h3>\n\n<p>1) Fork the repo and clone it locally.\n2) Make your modifications.\n3) Use Docker or a virtual environment to run tests and make sure they pass.\n4) Prettify your code.\n5) <strong>DO NOT GENERATE DOCS</strong>.\n    - We will generate the docs and update the version number when we are ready to release a new version.\n6) Only commit relevant changes and add clear commit messages.\n    - Atomic commits are preferred.\n7) Submit a pull request.</p>\n\n<h3 id=\"docker\">Docker</h3>\n\n<p>Make sure Docker is installed and running.</p>\n\n<ul>\n<li>Create a docker container and drop into a shell\n<ul>\n<li><code>./run.sh</code></li>\n</ul></li>\n<li>Run all tests (see ./utils/test.sh)\n<ul>\n<li><code>./run.sh test</code></li>\n</ul></li>\n<li><p>Prettify the code (see ./utils/prettify.sh)</p>\n\n<ul>\n<li><code>./run.sh prettify</code></li>\n</ul></li>\n<li><p>Note: You can and should modify the <code>Dockerfile</code> to test different python versions.</p></li>\n</ul>\n\n<h3 id=\"virtual-environment\">Virtual Environment</h3>\n\n<ul>\n<li>Create a virtual environment\n<ul>\n<li><code>python3.XX -m venv venv</code>\n<ul>\n<li>Replace <code>3.XX</code> with your python version (3.11 or higher)</li>\n</ul></li>\n</ul></li>\n<li>Activate the virtual environment\n<ul>\n<li><code>source venv/bin/activate</code></li>\n</ul></li>\n<li>Install the development requirements\n<ul>\n<li><code>pip install -r requirements/dev.txt</code></li>\n</ul></li>\n<li>Run Tests\n<ul>\n<li><code>./utils/test.sh</code></li>\n</ul></li>\n<li>Prettify Code\n<ul>\n<li><code>./utils/prettify.sh</code></li>\n</ul></li>\n</ul>\n"}, {"fullname": "bmsspy.core", "modulename": "bmsspy.core", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.is_pivot", "modulename": "bmsspy.core", "qualname": "is_pivot", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Returns True if the number of reachable nodes meets or exceeds a given threshold.</li>\n<li>Returns False otherwise.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li><code>root</code>\n<ul>\n<li>Type: int</li>\n<li>What: The starting node for the DFS traversal.</li>\n</ul></li>\n<li><code>forest</code>\n<ul>\n<li>Type: dict[int, set[int]]</li>\n<li>What: Adjacency list representing the directed forest.</li>\n</ul></li>\n<li><code>threshold</code>\n<ul>\n<li>Type: int</li>\n<li>What: The minimum number of reachable nodes required to return True.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">root</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">forest</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>, </span><span class=\"param\"><span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.core.BmsspCore", "modulename": "bmsspy.core", "qualname": "BmsspCore", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.__init__", "modulename": "bmsspy.core", "qualname": "BmsspCore.__init__", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Initialize the BMSSP solver with a graph represented as an adjacency list.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>graph:\n<ul>\n<li>Type: list[dict[int, int | float]]</li>\n<li>Description: The graph is represented as an adjacency list, where each node points to a dictionary of its neighbors and their edge weights.</li>\n<li>Note: This graph should be in a max degree 2 (no more than two in connections and/or no more than two out connections per node) to function correctly.</li>\n</ul></li>\n<li>origin_ids:\n<ul>\n<li>Type: set[int] | int</li>\n<li>What: The IDs of the starting nodes for the BMSSP algorithm.</li>\n<li>Note: Can be a single integer or a set of integers.</li>\n</ul></li>\n<li>counter_value:\n<ul>\n<li>Type: int</li>\n<li>What: The increment value (counter) added to the distance matrix to track how many edges have been traversed (used for unique path lengths).\n<ul>\n<li>Note: This should be set such that the maximum possible path length multiplied by counter_value is less than half of a single decimal place at the precision level.</li>\n</ul></li>\n</ul></li>\n<li>edge_adj_graph:\n<ul>\n<li>Type: list[dict[int, int | float]]</li>\n<li>What: The adjustment graph used to ensure unique path lengths.\n<ul>\n<li>Note: This should include edge id based adjustments.</li>\n<li>Note: The largest edge id based adjustment should be less than half of the counter_value</li>\n</ul></li>\n</ul></li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>data_structure:\n<ul>\n<li>Type: class</li>\n<li>Default: BmsspDataStructure</li>\n<li>What: The data structure class to be used for managing the frontier during the BMSSP algorithm.</li>\n</ul></li>\n<li>pivot_relaxation_steps:\n<ul>\n<li>Type: int | None</li>\n<li>Default: ceil(log(len(graph), 2) ** (1 / 3))</li>\n<li>What: The number of relaxation steps to perform when finding pivots (k). If None, it will be computed based on the graph size.</li>\n</ul></li>\n<li>target_tree_depth:\n<ul>\n<li>Type: int | None</li>\n<li>Default: int(log(len(graph), 2) ** (2 / 3))</li>\n<li>What: The target depth of the search tree (t). If None, it will be computed based on the graph size.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">graph</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">origin_ids</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">counter_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">edge_adj_graph</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\tdata_structure=&lt;class &#x27;bmsspy.data_structures.list_data_structure.ListBmsspDataStructure&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">pivot_relaxation_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_tree_depth</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "bmsspy.core.BmsspCore.graph", "modulename": "bmsspy.core", "qualname": "BmsspCore.graph", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.counter_and_edge_distance_matrix", "modulename": "bmsspy.core", "qualname": "BmsspCore.counter_and_edge_distance_matrix", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.counter_distance_matrix", "modulename": "bmsspy.core", "qualname": "BmsspCore.counter_distance_matrix", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.edge_adj_graph", "modulename": "bmsspy.core", "qualname": "BmsspCore.edge_adj_graph", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.counter_value", "modulename": "bmsspy.core", "qualname": "BmsspCore.counter_value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.predecessor", "modulename": "bmsspy.core", "qualname": "BmsspCore.predecessor", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.data_structure", "modulename": "bmsspy.core", "qualname": "BmsspCore.data_structure", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.max_recursion_depth", "modulename": "bmsspy.core", "qualname": "BmsspCore.max_recursion_depth", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.recursion_counter", "modulename": "bmsspy.core", "qualname": "BmsspCore.recursion_counter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.recursion_data_struct_maps", "modulename": "bmsspy.core", "qualname": "BmsspCore.recursion_data_struct_maps", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.core.BmsspCore.find_pivots", "modulename": "bmsspy.core", "qualname": "BmsspCore.find_pivots", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Finds pivot sets pivots and temp_frontier according to Algorithm 1.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>upper_bound:\n<ul>\n<li>Type: int | float</li>\n<li>What: The upper bound threshold (B)</li>\n</ul></li>\n<li>frontier:\n<ul>\n<li>Type: set[int]</li>\n<li>What: Set of vertices (S)</li>\n</ul></li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>None</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>pivots:\n<ul>\n<li>Type: Set[int]</li>\n<li>What: Set of pivot vertices</li>\n</ul></li>\n<li>frontier:\n<ul>\n<li>Type: Set[int]</li>\n<li>What: Return a new frontier set of vertices within the upper_bound</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">frontier</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.core.BmsspCore.base_case", "modulename": "bmsspy.core", "qualname": "BmsspCore.base_case", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Implements Algorithm 2: Base Case of BMSSP</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>upper_bound:\n<ul>\n<li>Type: int | float</li>\n</ul></li>\n<li>frontier:\n<ul>\n<li>Type: set</li>\n<li>What: Set with a single vertex x (complete)</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>new_upper_bound:\n<ul>\n<li>Type: int | float</li>\n<li>What: The new upper bound for the search</li>\n</ul></li>\n<li>new_frontier:\n<ul>\n<li>Type: set[int]</li>\n<li>What: Set of vertices v such that distance_matrix[v] &lt; new_upper_bound</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">frontier</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.core.BmsspCore.recursive_bmssp", "modulename": "bmsspy.core", "qualname": "BmsspCore.recursive_bmssp", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Implements Algorithm 3: Bounded Multi-Source Shortest Path (BMSSP)</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>recursion_depth:\n<ul>\n<li>Type: int</li>\n<li>What: The depth of the recursion</li>\n</ul></li>\n<li>upper_bound:\n<ul>\n<li>Type: float</li>\n<li>What: The upper bound for the search</li>\n</ul></li>\n<li>frontier:\n<ul>\n<li>Type: set[int]</li>\n<li>What: The set of vertices to explore</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>new_upper_bound:\n<ul>\n<li>Type: int | float</li>\n<li>What: The new upper bound for the search</li>\n</ul></li>\n<li>new_frontier:\n<ul>\n<li>Type: set[int]</li>\n<li>What: Set of vertices v such that distance_matrix[v] &lt; new_upper_bound</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">recursion_depth</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">frontier</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures", "modulename": "bmsspy.data_structures", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure", "modulename": "bmsspy.data_structures.data_structure", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.inf", "modulename": "bmsspy.data_structures.data_structure", "qualname": "inf", "kind": "variable", "doc": "<p></p>\n", "default_value": "inf"}, {"fullname": "bmsspy.data_structures.data_structure.is_lowest_value", "modulename": "bmsspy.data_structures.data_structure", "qualname": "is_lowest_value", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">linked_list_chain</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedListNode", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedListNode", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedListNode.__init__", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedListNode.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">parent_list</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedListNode.key", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedListNode.key", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedListNode.value", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedListNode.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedListNode.parent_list", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedListNode.parent_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedListNode.next", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedListNode.next", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedListNode.prev", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedListNode.prev", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.head", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.head", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.tail", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.tail", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.size", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.upper_bound", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.upper_bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.prev_list", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.prev_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.next_list", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.next_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.append", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.append", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.remove", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.remove", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.LinkedList.is_empty", "modulename": "bmsspy.data_structures.data_structure", "qualname": "LinkedList.is_empty", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure", "kind": "class", "doc": "<p>Data structure for inserting, updating and pulling the M smallest key-value pairs\ntogether with a lower bound on the remaining values (or B if empty), as required by Alg. 3.</p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.__init__", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">subset_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">recursion_data_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">recursion_data_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">data_structures</span><span class=\"o\">.</span><span class=\"n\">data_structure</span><span class=\"o\">.</span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span></span>)</span>"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.subset_size", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.subset_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.pull_size", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.pull_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.upper_bound", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.upper_bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.keys", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.keys", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.D0", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.D0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.D1", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.D1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.delete_d1", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.delete_d1", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.delete_d0", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.delete_d0", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.insert_key_value", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.insert_key_value", "kind": "function", "doc": "<p>Insert/refresh a key-value pair;</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.split", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.split", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">linked_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.batch_prepend", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.batch_prepend", "kind": "function", "doc": "<p>Insert/refresh multiple key-value pairs at once.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key_value_pairs</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.pull", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.pull", "kind": "function", "doc": "<p>Return (remaining_best, subset) where subset is up to self.subset_size keys with <em>globally</em> smallest values.\nRemove the returned keys from the structure (matching Alg. 3 semantics).\nremaining_best is the smallest value still present after removal, or self.upper_bound if empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.data_structure.BmsspDataStructure.is_empty", "modulename": "bmsspy.data_structures.data_structure", "qualname": "BmsspDataStructure.is_empty", "kind": "function", "doc": "<p>Check for empty data structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.heap_data_structure", "modulename": "bmsspy.data_structures.heap_data_structure", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.heap_data_structure.inf", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "inf", "kind": "variable", "doc": "<p></p>\n", "default_value": "inf"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure", "kind": "class", "doc": "<p>Data structure for inserting, updating and pulling the M smallest key-value pairs\ntogether with a lower bound on the remaining values (or B if empty), as required by Alg. 3.</p>\n"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.__init__", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">subset_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.subset_size", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.subset_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.upper_bound", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.upper_bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.heap", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.heap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.insert_key_value", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.insert_key_value", "kind": "function", "doc": "<p>Insert/refresh a key-value pair;</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.is_empty", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.is_empty", "kind": "function", "doc": "<p>Check for empty data structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.pull", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.pull", "kind": "function", "doc": "<p>Return (remaining_best, subset) where subset is up to self.subset_size keys with <em>globally</em> smallest values.\nRemove the returned keys from the structure (matching Alg. 3 semantics).\nremaining_best is the smallest value still present after removal, or self.upper_bound if empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.heap_data_structure.BmsspHeapDataStructure.batch_prepend", "modulename": "bmsspy.data_structures.heap_data_structure", "qualname": "BmsspHeapDataStructure.batch_prepend", "kind": "function", "doc": "<p>Insert/refresh multiple key-value pairs at once.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key_value_pairs</span><span class=\"p\">:</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure", "modulename": "bmsspy.data_structures.list_data_structure", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.inf", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "inf", "kind": "variable", "doc": "<p></p>\n", "default_value": "inf"}, {"fullname": "bmsspy.data_structures.list_data_structure.is_lowest_value", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "is_lowest_value", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">linked_list_chain</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedListNode", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedListNode", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedListNode.__init__", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedListNode.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">parent_list</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedListNode.key", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedListNode.key", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedListNode.value", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedListNode.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedListNode.parent_list", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedListNode.parent_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedListNode.next", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedListNode.next", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedListNode.prev", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedListNode.prev", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.head", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.head", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.tail", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.tail", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.size", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.upper_bound", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.upper_bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.prev_list", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.prev_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.next_list", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.next_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.append", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.append", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.remove", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.remove", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.LinkedList.is_empty", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "LinkedList.is_empty", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure", "kind": "class", "doc": "<p>Data structure for inserting, updating and pulling the M smallest key-value pairs\ntogether with a lower bound on the remaining values (or B if empty), as required by Alg. 3.\nThis simpler version only works when all inserted values are unique.</p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.__init__", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">subset_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">recursion_data_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">recursion_data_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">data_structures</span><span class=\"o\">.</span><span class=\"n\">list_data_structure</span><span class=\"o\">.</span><span class=\"n\">LinkedListNode</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.subset_size", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.subset_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.pull_size", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.pull_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.upper_bound", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.upper_bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.keys", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.keys", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.recursion_data_id", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.recursion_data_id", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.D0", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.D0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.D1", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.D1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.delete_d1", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.delete_d1", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.delete_d0", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.delete_d0", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.insert_key_value", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.insert_key_value", "kind": "function", "doc": "<p>Insert/refresh a key-value pair;</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.split", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.split", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">linked_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.batch_prepend", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.batch_prepend", "kind": "function", "doc": "<p>Insert/refresh multiple key-value pairs at once.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key_value_pairs</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.pull", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.pull", "kind": "function", "doc": "<p>Return (remaining_best, subset) where subset is up to self.subset_size keys with <em>globally</em> smallest values.\nRemove the returned keys from the structure (matching Alg. 3 semantics).\nremaining_best is the smallest value still present after removal, or self.upper_bound if empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.list_data_structure.ListBmsspDataStructure.is_empty", "modulename": "bmsspy.data_structures.list_data_structure", "qualname": "ListBmsspDataStructure.is_empty", "kind": "function", "doc": "<p>Check for empty data structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure", "modulename": "bmsspy.data_structures.unique_data_structure", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.inf", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "inf", "kind": "variable", "doc": "<p></p>\n", "default_value": "inf"}, {"fullname": "bmsspy.data_structures.unique_data_structure.is_lowest_value", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "is_lowest_value", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">linked_list_chain</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedListNode", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedListNode", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedListNode.__init__", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedListNode.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">parent_list</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedListNode.key", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedListNode.key", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedListNode.value", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedListNode.value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedListNode.parent_list", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedListNode.parent_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedListNode.next", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedListNode.next", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedListNode.prev", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedListNode.prev", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.head", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.head", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.tail", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.tail", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.size", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.upper_bound", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.upper_bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.prev_list", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.prev_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.next_list", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.next_list", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.append", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.append", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span>, </span><span class=\"param\"><span class=\"n\">value</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.remove", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.remove", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.LinkedList.is_empty", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "LinkedList.is_empty", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure", "kind": "class", "doc": "<p>Data structure for inserting, updating and pulling the M smallest key-value pairs\ntogether with a lower bound on the remaining values (or B if empty), as required by Alg. 3.\nThis simpler version only works when all inserted values are unique.</p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.__init__", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">subset_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">upper_bound</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.subset_size", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.subset_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.pull_size", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.pull_size", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.upper_bound", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.upper_bound", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.keys", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.keys", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.D0", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.D0", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.D1", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.D1", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.delete_d1", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.delete_d1", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.delete_d0", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.delete_d0", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.insert_key_value", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.insert_key_value", "kind": "function", "doc": "<p>Insert/refresh a key-value pair;</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.split", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.split", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">linked_list</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.batch_prepend", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.batch_prepend", "kind": "function", "doc": "<p>Insert/refresh multiple key-value pairs at once.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key_value_pairs</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.pull", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.pull", "kind": "function", "doc": "<p>Return (remaining_best, subset) where subset is up to self.subset_size keys with <em>globally</em> smallest values.\nRemove the returned keys from the structure (matching Alg. 3 semantics).\nremaining_best is the smallest value still present after removal, or self.upper_bound if empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.data_structures.unique_data_structure.UniqueBmsspDataStructure.is_empty", "modulename": "bmsspy.data_structures.unique_data_structure", "qualname": "UniqueBmsspDataStructure.is_empty", "kind": "function", "doc": "<p>Check for empty data structure.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.entrypoint", "modulename": "bmsspy.entrypoint", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.entrypoint.Bmssp", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.entrypoint.Bmssp.__init__", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp.__init__", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Initialize a BMSSP-style shortest path object that can execute a bmssp solve method.</li>\n<li>Calculates and stores necessary variables for unique path length adjustments.</li>\n<li>Optionally calculate the constant degree graph and related info.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li><code>graph</code>:\n<ul>\n<li>Type: list of dictionaries</li>\n<li>What: The input graph represented as a list of dictionaries where each index represents a node id.\nEach dictionary contains neighboring node ids as keys and edge weights as values.</li>\n</ul></li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li><code>precision</code>:\n<ul>\n<li>Type: int</li>\n<li>Default: 6</li>\n<li>What: The decimal precision to round edge weights to for calculations\n<ul>\n<li>Note: This is necessary to ensure that the unique values added to each edge weight do not cause issues with expected returned path lengths.</li>\n</ul></li>\n</ul></li>\n<li><code>use_constant_degree_graph</code>:\n<ul>\n<li>Type: bool</li>\n<li>Default: True</li>\n<li>What: Whether to convert the input graph to a constant degree graph to match the original BMSSP algorithm requirements.</li>\n<li>Note: It appears that this is not necessary for solving the algorithm, but is used to achieve big O complexity targets.\nThis is default to True even though it appears to be slower in practice for all the graphs we have tested thus far.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">graph</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">precision</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">6</span>,</span><span class=\"param\">\t<span class=\"n\">use_constant_degree_graph</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "bmsspy.entrypoint.Bmssp.graph", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp.graph", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.entrypoint.Bmssp.precision", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp.precision", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.entrypoint.Bmssp.use_constant_degree_graph", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp.use_constant_degree_graph", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.entrypoint.Bmssp.counter_value", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp.counter_value", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.entrypoint.Bmssp.edge_adj_graph", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp.edge_adj_graph", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.entrypoint.Bmssp.solve", "modulename": "bmsspy.entrypoint", "qualname": "Bmssp.solve", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>A Full BMSSP-style shortest path solver.</li>\n<li>Return a dictionary of various path information including:\n<ul>\n<li><code>id_path</code>: A list of node ids in the order they are visited</li>\n<li><code>path</code>: A list of node dictionaries (lat + long) in the order they are visited</li>\n</ul></li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li><code>origin_id</code>\n<ul>\n<li>Type: int | set of int</li>\n<li>What: The id of the origin node from the graph dictionary to start the shortest path from</li>\n<li>Note: If you pass a set, only the first id in the set will be checked for input validation</li>\n</ul></li>\n<li><code>destination_id</code>\n<ul>\n<li>Type: int | None</li>\n<li>What: The id of the destination node from the graph dictionary to end the shortest path at</li>\n<li>Note: If None, returns the distance matrix and predecessor list for the origin node</li>\n<li>Note: If provided, returns the shortest path [origin_id, ..., destination_id] and its length</li>\n</ul></li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>pivot_relaxation_steps:\n<ul>\n<li>Type: int | None</li>\n<li>Default: ceil(log(len(graph), 2) ** (1 / 3))</li>\n<li>What: The number of relaxation steps to perform when finding pivots (k). If None, it will be computed based on the graph size.</li>\n</ul></li>\n<li>target_tree_depth:\n<ul>\n<li>Type: int | None</li>\n<li>Default: int(log(len(graph), 2) ** (2 / 3))</li>\n<li>What: The target depth of the search tree (t). If None, it will be computed based on the graph size.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>A dictionary with the following keys\n<ul>\n<li><code>origin_id</code>: The id of the origin node or a list of ids if a set was provided</li>\n<li><code>destination_id</code>: The id of the destination node (or None)</li>\n<li><code>predecessor</code>: The predecessor list for path reconstruction</li>\n<li><code>distance_matrix</code>: The distance matrix from the origin node to all other nodes</li>\n<li><code>path</code>: The shortest path from origin_id to destination_id (or None)</li>\n<li><code>length</code>: The length of the shortest path from origin_id to destination_id (or None)</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">origin_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">destination_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\tdata_structure=&lt;class &#x27;bmsspy.data_structures.data_structure.BmsspDataStructure&#x27;&gt;,</span><span class=\"param\">\t<span class=\"n\">pivot_relaxation_steps</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_tree_depth</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers", "modulename": "bmsspy.helpers", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.heapdict", "modulename": "bmsspy.helpers.heapdict", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.heapdict.heapdict", "modulename": "bmsspy.helpers.heapdict", "qualname": "heapdict", "kind": "class", "doc": "<p>A MutableMapping is a generic container for associating\nkey/value pairs.</p>\n\n<p>This class provides concrete generic implementations of all\nmethods except for __getitem__, __setitem__, __delitem__,\n__iter__, and __len__.</p>\n", "bases": "collections.abc.MutableMapping"}, {"fullname": "bmsspy.helpers.heapdict.heapdict.__init__", "modulename": "bmsspy.helpers.heapdict", "qualname": "heapdict.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kw</span></span>)</span>"}, {"fullname": "bmsspy.helpers.heapdict.heapdict.heap", "modulename": "bmsspy.helpers.heapdict", "qualname": "heapdict.heap", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.heapdict.heapdict.d", "modulename": "bmsspy.helpers.heapdict", "qualname": "heapdict.d", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.heapdict.heapdict.clear", "modulename": "bmsspy.helpers.heapdict", "qualname": "heapdict.clear", "kind": "function", "doc": "<p>D.clear() -> None.  Remove all items from D.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.heapdict.heapdict.popitem", "modulename": "bmsspy.helpers.heapdict", "qualname": "heapdict.popitem", "kind": "function", "doc": "<p>D.popitem() -> (k, v), remove and return the (key, value) pair with lowest\nvalue; but raise KeyError if D is empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.heapdict.heapdict.peekitem", "modulename": "bmsspy.helpers.heapdict", "qualname": "heapdict.peekitem", "kind": "function", "doc": "<p>D.peekitem() -> (k, v), return the (key, value) pair with lowest value;\nbut raise KeyError if D is empty.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.quicksplit", "modulename": "bmsspy.helpers.quicksplit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.quicksplit.median", "modulename": "bmsspy.helpers.quicksplit", "qualname": "median", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Calculates the median of a list of numbers by sorting the list and finding the middle value or the average of the two middle values.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>arr: A list of integers or floats.</li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>split: A boolean indicating weather to calculate a split if the list length is even\n<ul>\n<li>Default is True</li>\n<li>If True, the median is the average of the two middle values for even-length lists</li>\n<li>If False, the median is the lower of the two middle values for even-length lists</li>\n<li>If False, this ensures that the returned median is always an element of the original list</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>The median value as an integer or float.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">split</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.quicksplit.median_of_medians", "modulename": "bmsspy.helpers.quicksplit", "qualname": "median_of_medians", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Computes the median of medians of a list of numbers.</li>\n<li>This is done by dividing the list into sublists of a fixed size (5 in this case)\n<ul>\n<li>For each sublist, find the median of each sublist</li>\n<li>Then iteratively find the median of those medians</li>\n<li>Stop when the list is smaller than or equal to the split size and return the median of that list</li>\n</ul></li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>arr: A list of integers or floats.</li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>split: A boolean indicating weather to calculate a split value if the final iterated length is even\n<ul>\n<li>Default is True</li>\n<li>If True, the median is the average of the two middle values for even-length lists</li>\n<li>If False, the median is the lower of the two middle values for even-length lists</li>\n<li>If False, this ensures that the returned median is always an element of the original list</li>\n</ul></li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>split_size: The size of the sublists to create\n<ul>\n<li>Default is 5</li>\n<li>Must be an odd number to ensure a single median value</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">split_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">split</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.quicksplit.quicksplit", "modulename": "bmsspy.helpers.quicksplit", "qualname": "quicksplit", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Splits an array into two buckets using a variant of the Quickselect algorithm.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>arr: A list of integers or floats to be split.</li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>lower_bucket_size: The desired size of the lower bucket.\n<ul>\n<li>If not provided, the function will split the array into two equal halves (or as close as possible).</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>A dictionary with three keys:\n<ul>\n<li>'lower': A list containing the lower bucket of elements.</li>\n<li>'higher': A list containing the higher bucket of elements.</li>\n<li>'pivot': The max value in the lower bucket or None if the lower bucket is empty (i.e., lower_bucket_size is 0).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">lower_bucket_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.quicksplit.quicksplit_tuple", "modulename": "bmsspy.helpers.quicksplit", "qualname": "quicksplit_tuple", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Splits a list of tuples into two lists using a variant of the Quickselect algorithm.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>data: A list of tuples where each tuple contains a key (any hashable type) and a value (integer or float) to be split.</li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>lower_bucket_size: The desired size of the lower bucket.\n<ul>\n<li>If not provided, the function will split the array into two equal halves (or as close as possible).</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>A dictionary with three keys:\n<ul>\n<li>'lower': A list of tuples in the lower bucket.</li>\n<li>'higher': A list of tuples in the higher bucket.</li>\n<li>'pivot': The max value in the lower bucket or None if the lower bucket is empty (i.e., lower_bucket_size is 0).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">lower_bucket_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.quicksplit.quicksplit_dict", "modulename": "bmsspy.helpers.quicksplit", "qualname": "quicksplit_dict", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Splits a dictionary of values into two dicts using a variant of the Quickselect algorithm.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>data: A dictionary where keys are any hashable type and values are lists of integers or floats to be split.</li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>lower_bucket_size: The desired size of the lower bucket.\n<ul>\n<li>If not provided, the function will split the array into two equal halves (or as close as possible).</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>A dictionary with three keys:\n<ul>\n<li>'lower': A dict of the lower bucket of elements.</li>\n<li>'higher': A dict of the higher bucket of elements.</li>\n<li>'pivot': The max value in the lower bucket or None if the lower bucket is empty (i.e., lower_bucket_size is 0).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">lower_bucket_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.quicksplit.sortsplit", "modulename": "bmsspy.helpers.quicksplit", "qualname": "sortsplit", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Splits an array into two buckets by sorting the array and dividing it at a specified index.</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li>arr: A list of integers or floats to be split.</li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>lower_bucket_size: The desired size of the lower bucket.\n<ul>\n<li>If not provided, the function will split the array into two equal halves (or as close as possible).</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>A dictionary with three keys:\n<ul>\n<li>'lower': A list containing the lower bucket of elements.</li>\n<li>'higher': A list containing the higher bucket of elements.</li>\n<li>'pivot': The max value in the lower bucket.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">lower_bucket_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree", "modulename": "bmsspy.helpers.rbtree", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.BSNode", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.BSNode.__init__", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode.__init__", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Initialize a binary search tree node with a key and a value.</li>\n</ul>\n\n<p>Required Parameters:</p>\n\n<ul>\n<li>key: The key associated with the node.\n<ul>\n<li>What: Any data type that supports comparison operations.</li>\n<li>Why: Used to maintain the binary search tree property.</li>\n<li>Example: An integer, string, or custom object with comparison methods.</li>\n</ul></li>\n</ul>\n\n<p>Optional Parameters:</p>\n\n<ul>\n<li>value: The value associated with the node.\n<ul>\n<li>What: Any data type.</li>\n<li>Why: Stores the data or information related to the key.</li>\n<li>Default: None</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span>, </span><span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "bmsspy.helpers.rbtree.BSNode.key", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode.key", "kind": "variable", "doc": "<p></p>\n", "annotation": ": &lt;built-in function any&gt;"}, {"fullname": "bmsspy.helpers.rbtree.BSNode.val", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode.val", "kind": "variable", "doc": "<p></p>\n", "annotation": ": &lt;built-in function any&gt;"}, {"fullname": "bmsspy.helpers.rbtree.BSNode.parent", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode.parent", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bmsspy.helpers.rbtree.BSNode | None"}, {"fullname": "bmsspy.helpers.rbtree.BSNode.left", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode.left", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bmsspy.helpers.rbtree.BSNode | None"}, {"fullname": "bmsspy.helpers.rbtree.BSNode.right", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode.right", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bmsspy.helpers.rbtree.BSNode | None"}, {"fullname": "bmsspy.helpers.rbtree.BSNode.num_nodes", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSNode.num_nodes", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Count the number of nodes in the subtree rooted at this node.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>int: The total number of nodes in the subtree.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree.BSTree", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.BSTree.__init__", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree.__init__", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Initialize an empty binary search tree.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "bmsspy.helpers.rbtree.BSTree.root", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree.root", "kind": "variable", "doc": "<p></p>\n", "annotation": ": bmsspy.helpers.rbtree.BSNode | None"}, {"fullname": "bmsspy.helpers.rbtree.BSTree.insert", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree.insert", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>A placeholder method for inserting a key-value pair into the binary search tree.</li>\n<li>Note: This method is not implemented in the base class and should be overridden in subclasses.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree.BSTree.remove", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree.remove", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>A placeholder method for removing a node with the specified key from the binary search tree.</li>\n<li>Note: This method is not implemented in the base class and should be overridden in subclasses</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree.BSTree.find", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree.find", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Find a node in the binary search tree based on the specified key and target type.</li>\n</ul>\n\n<p>Required Parameters:</p>\n\n<ul>\n<li>key: The key to search for in the tree.\n<ul>\n<li>What: Any data type that supports comparison operations.</li>\n<li>Why: Used to locate the desired node in the tree.</li>\n<li>Example: An integer, string, or custom object with comparison methods.</li>\n</ul></li>\n</ul>\n\n<p>Opional Parameters:</p>\n\n<ul>\n<li>target: The type of search to perform. Options are 'exact', 'upper', or 'lower'.\n<ul>\n<li>What: A string indicating the search type.</li>\n<li>Why: Determines how the search is conducted.</li>\n<li>Default: 'exact'</li>\n<li>Options:\n<ul>\n<li>'exact': Find the node with the exact key.</li>\n<li>'upper': Find the smallest node with a key greater than or equal to the specified key.</li>\n<li>'lower': Find the largest node with a key less than or equal to the specified key.</li>\n</ul></li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>BSNode | None: The found node based on the search criteria, or None if no such node exists.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;exact&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">helpers</span><span class=\"o\">.</span><span class=\"n\">rbtree</span><span class=\"o\">.</span><span class=\"n\">BSNode</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree.BSTree.get_max", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree.get_max", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Find the maximum node in the subtree rooted at the given node.</li>\n</ul>\n\n<p>Required Parameters:</p>\n\n<ul>\n<li>node: The root node of the subtree to search.\n<ul>\n<li>What: A BSNode instance.</li>\n<li>Why: Used to locate the maximum node in the subtree.</li>\n<li>Example: The root node of the subtree.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>BSNode | None: The maximum node in the subtree, or None if the subtree is empty.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">helpers</span><span class=\"o\">.</span><span class=\"n\">rbtree</span><span class=\"o\">.</span><span class=\"n\">BSNode</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">helpers</span><span class=\"o\">.</span><span class=\"n\">rbtree</span><span class=\"o\">.</span><span class=\"n\">BSNode</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree.BSTree.get_min", "modulename": "bmsspy.helpers.rbtree", "qualname": "BSTree.get_min", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Find the minimum node in the subtree rooted at the given node.</li>\n</ul>\n\n<p>Required Parameters:</p>\n\n<ul>\n<li>node: The root node of the subtree to search.\n<ul>\n<li>What: A BSNode instance.</li>\n<li>Why: Used to locate the minimum node in the subtree.</li>\n<li>Example: The root node of the subtree.</li>\n</ul></li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>BSNode | None: The minimum node in the subtree, or None if the subtree is empty.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">node</span><span class=\"p\">:</span> <span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">helpers</span><span class=\"o\">.</span><span class=\"n\">rbtree</span><span class=\"o\">.</span><span class=\"n\">BSNode</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">helpers</span><span class=\"o\">.</span><span class=\"n\">rbtree</span><span class=\"o\">.</span><span class=\"n\">BSNode</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree.RBNode", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBNode", "kind": "class", "doc": "<p></p>\n", "bases": "BSNode"}, {"fullname": "bmsspy.helpers.rbtree.RBNode.__init__", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBNode.__init__", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Initialize a red-black tree node with a key, value, and color.</li>\n</ul>\n\n<p>Required Parameters:</p>\n\n<ul>\n<li>key: The key associated with the node.\n<ul>\n<li>What: Any data type that supports comparison operations.</li>\n<li>Why: Used to maintain the binary search tree property.</li>\n<li>Example: An integer, string, or custom object with comparison methods.</li>\n</ul></li>\n<li>color: The color of the node (True for red, False for black).\n<ul>\n<li>What: A boolean value.</li>\n<li>Why: Used to maintain the red-black tree properties.</li>\n<li>Example: True (red) or False (black).</li>\n</ul></li>\n</ul>\n\n<p>Optional Parameters:</p>\n\n<ul>\n<li>value: The value associated with the node.\n<ul>\n<li>What: Any data type.</li>\n<li>Why: Stores the data or information related to the key.</li>\n<li>Default: None</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">color</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span>)</span>"}, {"fullname": "bmsspy.helpers.rbtree.RBNode.colored", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBNode.colored", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.RBTreeRebalance", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTreeRebalance", "kind": "class", "doc": "<p>A class that provides rebalancing methods for a Red-Black Tree.</p>\n\n<p>This is used primarily for code organization and clarity.</p>\n"}, {"fullname": "bmsspy.helpers.rbtree.RBTreeFixup", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTreeFixup", "kind": "class", "doc": "<p>A class that provides fixup methods for a Red-Black Tree after deletion.\nThis is used primarily for code organization and clarity.</p>\n"}, {"fullname": "bmsspy.helpers.rbtree.RBTree", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree", "kind": "class", "doc": "<p>A class that provides rebalancing methods for a Red-Black Tree.</p>\n\n<p>This is used primarily for code organization and clarity.</p>\n", "bases": "BSTree, RBTreeRebalance, RBTreeFixup"}, {"fullname": "bmsspy.helpers.rbtree.RBTree.__init__", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree.__init__", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Initialize a Red-Black Tree, optionally with an initializer.</li>\n</ul>\n\n<p>Optional Parameters:</p>\n\n<ul>\n<li>initializer: A dictionary or list to initialize the tree with.\n<ul>\n<li>What: A dict with key-value pairs or a list of keys/tuples.</li>\n<li>Why: To populate the tree with initial data.</li>\n<li>Default: None</li>\n<li>Example:\n<ul>\n<li>dict: {key1: value1, key2: value2}</li>\n<li>list: [key1, key2] or [(key1, value1), (key2, value2)]</li>\n</ul></li>\n<li>Note: All keys should be comparable in order to maintain the tree properties.\n<ul>\n<li>Example: All keys are integers or strings.</li>\n<li>Invalid Example: Mixing integers and strings as keys.</li>\n<li>Custom objects used as keys should implement comparison methods.</li>\n</ul></li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">initializer</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">|</span> <span class=\"nb\">list</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "bmsspy.helpers.rbtree.RBTree.left_idx", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree.left_idx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.RBTree.right_idx", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree.right_idx", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.RBTree.rotations", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree.rotations", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.RBTree.fixups", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree.fixups", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.rbtree.RBTree.insert", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree.insert", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Insert a key-value pair into the Red-Black Tree.</li>\n<li>If a node with the same key already exists, its value is updated.</li>\n</ul>\n\n<p>Required Parameters:</p>\n\n<ul>\n<li>key: The key to insert into the tree.\n<ul>\n<li>What: Any data type that supports comparison operations.</li>\n<li>Why: Used to maintain the binary search tree property.</li>\n<li>Example: An integer, string, or custom object with comparison methods.</li>\n</ul></li>\n</ul>\n\n<p>Optional Parameters:</p>\n\n<ul>\n<li>value: The value associated with the key.\n<ul>\n<li>What: Any data type.</li>\n<li>Why: Stores the data or information related to the key.</li>\n<li>Default: None</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">bmsspy</span><span class=\"o\">.</span><span class=\"n\">helpers</span><span class=\"o\">.</span><span class=\"n\">rbtree</span><span class=\"o\">.</span><span class=\"n\">RBNode</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.rbtree.RBTree.remove", "modulename": "bmsspy.helpers.rbtree", "qualname": "RBTree.remove", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Remove a node with the specified key from the Red-Black Tree.</li>\n<li>Note: If the key is not found, the tree remains unchanged.</li>\n</ul>\n\n<p>Required Parameters:</p>\n\n<ul>\n<li>key: The key of the node to remove from the tree.\n<ul>\n<li>What: Any data type that supports comparison operations.</li>\n<li>Why: Used to locate the node to be removed.</li>\n<li>Example: An integer, string, or custom object with comparison methods.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"nb\">any</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.utils", "modulename": "bmsspy.helpers.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "bmsspy.helpers.utils.inf", "modulename": "bmsspy.helpers.utils", "qualname": "inf", "kind": "variable", "doc": "<p></p>\n", "default_value": "Decimal(&#x27;Infinity&#x27;)"}, {"fullname": "bmsspy.helpers.utils.input_check", "modulename": "bmsspy.helpers.utils", "qualname": "input_check", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Check that the inputs passed to the shortest path algorithm are valid</li>\n<li>Raises an exception if the inputs passed are not valid</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li><code>graph</code>:\n<ul>\n<li>Type: list of dictionaries</li>\n</ul></li>\n<li><code>origin_id</code>\n<ul>\n<li>Type: int</li>\n<li>What: The id of the origin node from the graph dictionary to start the shortest path from</li>\n</ul></li>\n<li><code>destination_id</code>\n<ul>\n<li>Type: int</li>\n<li>What: The id of the destination node from the graph dictionary to end the shortest path at</li>\n</ul></li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>None</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">graph</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">origin_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">destination_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.utils.reconstruct_path", "modulename": "bmsspy.helpers.utils", "qualname": "reconstruct_path", "kind": "function", "doc": "<p>Function:</p>\n\n<ul>\n<li>Reconstruct the shortest path from the destination node to the origin node</li>\n<li>Return the reconstructed path in the correct order</li>\n<li>Given the predecessor list, this function reconstructs the path</li>\n</ul>\n\n<p>Required Arguments:</p>\n\n<ul>\n<li><code>destination_id</code>\n<ul>\n<li>Type: int</li>\n<li>What: The id of the destination node from the graph dictionary to end the shortest path at</li>\n</ul></li>\n<li><code>predecessor</code>\n<ul>\n<li>Type: list[int]</li>\n<li>What: The predecessor list that was used to compute the shortest path</li>\n<li>This list is used to reconstruct the path from the destination node to the origin node</li>\n<li>Note: Nodes with no predecessor should be -1</li>\n</ul></li>\n</ul>\n\n<p>Optional Arguments:</p>\n\n<ul>\n<li>None</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">destination_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">predecessor</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.utils.convert_to_constant_degree", "modulename": "bmsspy.helpers.utils", "qualname": "convert_to_constant_degree", "kind": "function", "doc": "<p>Convert a graph to a guaranteed unique path length based constant degree graph with no more than 2 incoming and 2 outgoing edges per node.</p>\n\n<p>The precision value determines the number of decimal places to maintain when adjusting edge weights to ensure unique path lengths.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>graph (list of dict): The input graph represented as an adjacency list.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict: A dictionary containing the converted constant degree graph and the output mapping.\n<ul>\n<li>'graph' (list of dict): The converted constant degree graph.</li>\n<li>'idx_map' (list of int): A mapping from all node indices to original node indices.\n<ul>\n<li>Eg: idx_map[5] = 2 means node 5 in the new graph corresponds to node 2 in the original graph.</li>\n<li>Note: All nodes below the original graph length map to themselves.</li>\n</ul></li>\n<li>'original_graph_len' (int): The length of the original graph.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">graph</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "bmsspy.helpers.utils.convert_from_constant_degree", "modulename": "bmsspy.helpers.utils", "qualname": "convert_from_constant_degree", "kind": "function", "doc": "<p>Convert the distance and predecessor matrices from a constant degree graph back to the equivalent matrices for the original graph.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>distance_matrix (list of float): The distance matrix from the constant degree graph.</li>\n<li>predecessor_matrix (list of int): The predecessor matrix from the constant degree graph.</li>\n<li>constant_degree_dict (dict): The dictionary returned by <code>convert_to_constant_degree</code> function.</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>dict: A dictionary containing the converted distance and predecessor matrices.\n<ul>\n<li>'distance_matrix' (list of float): The converted distance matrix for the original graph.</li>\n<li>'predecessor_matrix' (list of int): The converted predecessor matrix for the original graph.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">distance_matrix</span>, </span><span class=\"param\"><span class=\"n\">predecessor_matrix</span>, </span><span class=\"param\"><span class=\"n\">constant_degree_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();